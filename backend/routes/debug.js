const express = require('express');
const router = express.Router();
const gmailService = require('../services/gmailService');
const emailService = require('../services/emailService');
const passwordGenerator = require('../utils/passwordGenerator');
const bcrypt = require('bcrypt');

// Debug endpoint to check environment configuration
router.get('/env-check', (req, res) => {
    const envStatus = {
        EMAIL_USER: !!process.env.EMAIL_USER,
        GMAIL_CLIENT_ID: !!process.env.GMAIL_CLIENT_ID,
        GMAIL_CLIENT_SECRET: !!process.env.GMAIL_CLIENT_SECRET,
        GMAIL_REFRESH_TOKEN: !!process.env.GMAIL_REFRESH_TOKEN,
        EMAIL_PASS: !!process.env.EMAIL_PASS,
        NODE_ENV: process.env.NODE_ENV,
        timestamp: new Date().toISOString()
    };
    
    res.json({
        message: 'Environment variable status',
        config: envStatus,
        oauthConfigured: envStatus.EMAIL_USER && envStatus.GMAIL_CLIENT_ID && envStatus.GMAIL_CLIENT_SECRET && envStatus.GMAIL_REFRESH_TOKEN,
        appPasswordConfigured: envStatus.EMAIL_USER && envStatus.EMAIL_PASS
    });
});

// Test Gmail API teacher emails with auto-generated passwords
router.post('/test-teacher-email', async (req, res) => {
    try {
        const { type, email, useAutoGenerated = true } = req.body;
        
        console.log(`Testing ${type} email to:`, email);
        
        let result;
        if (type === 'approval') {
            // Generate password if requested
            const password = useAutoGenerated ? 
                passwordGenerator.generateKidFriendlyPassword() : 
                'ManualPassword123';
            
            console.log('Using password:', password);
            
            result = await gmailService.sendTeacherApprovalEmail(
                email || 'amitrace.vidpod@gmail.com',
                'Debug Test Teacher',
                email || 'debug_teacher@test.com',
                password
            );
        } else if (type === 'rejection') {
            result = await gmailService.sendTeacherRejectionEmail(
                email || 'amitrace.vidpod@gmail.com',
                'Debug Test Teacher'
            );
        } else {
            return res.status(400).json({ error: 'Type must be "approval" or "rejection"' });
        }
        
        console.log('Gmail API result:', result);
        
        res.json({
            message: `${type} email test completed`,
            success: result.success,
            passwordAutoGenerated: type === 'approval',
            result: result
        });
    } catch (error) {
        console.error('Debug email test error:', error);
        res.status(500).json({ 
            error: 'Email test failed', 
            details: error.message 
        });
    }
});

// Test password generation
router.get('/test-password-generation', (req, res) => {
    const { count = 10, format = 'kid-friendly' } = req.query;
    const passwords = [];
    const analysis = {
        uniqueCount: 0,
        averageLength: 0,
        strengthDistribution: {
            strong: 0,
            moderate: 0,
            weak: 0
        }
    };
    
    // Generate passwords
    for (let i = 0; i < parseInt(count); i++) {
        let password;
        if (format === 'secure') {
            password = passwordGenerator.generateSecurePassword();
        } else {
            password = passwordGenerator.generateKidFriendlyPassword();
        }
        
        // Validate the password
        const validation = passwordGenerator.validateGeneratedPassword(password);
        
        passwords.push({
            password,
            valid: validation.valid,
            strength: validation.strength,
            entropy: validation.entropy
        });
        
        // Update analysis
        analysis.averageLength += password.length;
        analysis.strengthDistribution[validation.strength]++;
    }
    
    // Calculate unique count
    analysis.uniqueCount = new Set(passwords.map(p => p.password)).size;
    analysis.averageLength = Math.floor(analysis.averageLength / passwords.length);
    
    // Get password statistics
    const stats = passwordGenerator.getPasswordStats();
    
    res.json({
        message: 'Password generation test',
        format,
        count: passwords.length,
        passwords,
        analysis,
        statistics: stats
    });
});

// Test password validation
router.post('/test-password-validation', (req, res) => {
    const { passwords } = req.body;
    
    if (!passwords || !Array.isArray(passwords)) {
        return res.status(400).json({ error: 'Please provide an array of passwords to validate' });
    }
    
    const results = passwords.map(password => {
        const validation = passwordGenerator.validateGeneratedPassword(password);
        return {
            password,
            ...validation
        };
    });
    
    const summary = {
        total: results.length,
        valid: results.filter(r => r.valid).length,
        invalid: results.filter(r => !r.valid).length,
        byStrength: {
            strong: results.filter(r => r.strength === 'strong').length,
            moderate: results.filter(r => r.strength === 'moderate').length,
            weak: results.filter(r => r.strength === 'weak').length
        }
    };
    
    res.json({
        message: 'Password validation results',
        results,
        summary
    });
});

// Test complete approval flow with auto-generated password
router.post('/test-approval-flow', async (req, res) => {
    const { teacherEmail = 'test@example.com', teacherName = 'Test Teacher' } = req.body;
    
    try {
        // 1. Generate password
        const generatedPassword = passwordGenerator.generateKidFriendlyPassword();
        console.log('Generated password:', generatedPassword);
        
        // 2. Hash password (simulate what would happen in DB)
        const saltRounds = 10;
        const hashedPassword = await bcrypt.hash(generatedPassword, saltRounds);
        
        // 3. Verify hash works
        const hashValid = await bcrypt.compare(generatedPassword, hashedPassword);
        
        // 4. Send email (try both services)
        let emailResult = await gmailService.sendTeacherApprovalEmail(
            teacherEmail,
            teacherName,
            teacherEmail,
            generatedPassword
        );
        
        if (!emailResult.success) {
            console.log('Gmail failed, trying SMTP...');
            emailResult = await emailService.sendTeacherApprovalEmail(
                teacherEmail,
                teacherName,
                teacherEmail,
                generatedPassword
            );
        }
        
        res.json({
            message: 'Approval flow test completed',
            password: {
                generated: generatedPassword,
                validation: passwordGenerator.validateGeneratedPassword(generatedPassword),
                hashValid
            },
            email: {
                sent: emailResult.success,
                service: emailResult.service || 'unknown',
                error: emailResult.error
            }
        });
    } catch (error) {
        console.error('Approval flow test error:', error);
        res.status(500).json({
            error: 'Approval flow test failed',
            details: error.message
        });
    }
});

// Debug password reset token flow
router.post('/test-token-flow', async (req, res) => {
    try {
        const tokenService = require('../utils/token-service');
        const { Pool } = require('pg');
        
        const pool = new Pool({
            connectionString: process.env.DATABASE_URL,
            ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
        });
        
        console.log('ðŸ§ª DEBUG: Starting token flow test');
        
        // Step 1: Get admin user
        const userResult = await pool.query('SELECT id, email FROM users WHERE email = $1', ['admin@vidpod.com']);
        if (userResult.rows.length === 0) {
            return res.status(404).json({ error: 'Admin user not found' });
        }
        
        const user = userResult.rows[0];
        console.log('ðŸ§ª DEBUG: Found user:', user);
        
        // Step 2: Count existing tokens
        const beforeCount = await pool.query('SELECT COUNT(*) as count FROM password_reset_tokens WHERE user_id = $1', [user.id]);
        console.log('ðŸ§ª DEBUG: Tokens before creation:', beforeCount.rows[0].count);
        
        // Step 3: Create token
        const token = await tokenService.createPasswordResetToken(user.id);
        console.log('ðŸ§ª DEBUG: Token creation completed, returned token:', token.substring(0, 16) + '...');
        
        // Step 4: Count tokens after creation
        const afterCount = await pool.query('SELECT COUNT(*) as count FROM password_reset_tokens WHERE user_id = $1', [user.id]);
        console.log('ðŸ§ª DEBUG: Tokens after creation:', afterCount.rows[0].count);
        
        // Step 5: Try to find the exact token
        const findResult = await pool.query('SELECT id, token, expires_at, created_at FROM password_reset_tokens WHERE token = $1', [token]);
        console.log('ðŸ§ª DEBUG: Direct token lookup result:', findResult.rows.length);
        
        // Step 6: Test validation
        const validation = await tokenService.validateToken(token);
        console.log('ðŸ§ª DEBUG: Token validation result:', validation.isValid);
        
        // Step 7: Get recent tokens for comparison
        const recentTokens = await pool.query(`
            SELECT id, user_id, token, expires_at, used, created_at 
            FROM password_reset_tokens 
            WHERE user_id = $1 
            ORDER BY created_at DESC 
            LIMIT 5
        `, [user.id]);
        
        res.json({
            message: 'Token flow debug test completed',
            user: { id: user.id, email: user.email },
            tokensBefore: parseInt(beforeCount.rows[0].count),
            tokensAfter: parseInt(afterCount.rows[0].count),
            createdToken: token.substring(0, 16) + '...',
            directLookup: findResult.rows.length > 0,
            validationResult: validation.isValid,
            validationError: validation.error,
            recentTokens: recentTokens.rows.map(t => ({
                id: t.id,
                token: t.token.substring(0, 16) + '...',
                expires: t.expires_at,
                used: t.used,
                created: t.created_at
            }))
        });
        
    } catch (error) {
        console.error('ðŸ§ª DEBUG: Token flow test error:', error);
        res.status(500).json({
            error: 'Debug test failed',
            details: error.message,
            stack: error.stack
        });
    }
});

// Get password generation statistics
router.get('/password-stats', (req, res) => {
    const stats = passwordGenerator.getPasswordStats();
    
    // Generate some samples
    const samples = {
        kidFriendly: [],
        secure: []
    };
    
    for (let i = 0; i < 5; i++) {
        samples.kidFriendly.push(passwordGenerator.generateKidFriendlyPassword());
        samples.secure.push(passwordGenerator.generateSecurePassword());
    }
    
    res.json({
        message: 'Password generator statistics',
        statistics: stats,
        samples,
        recommendations: {
            kidFriendly: 'Best for teacher accounts - easy to remember and type',
            secure: 'Use for admin accounts requiring maximum security'
        }
    });
});

module.exports = router;