/**
 * Validation Helper Utilities
 * Centralized validation functions for data integrity
 */

const validationHelpers = {
  /**
   * Validate email format
   * @param {string} email - Email to validate
   * @returns {boolean} True if valid email format
   */
  isValidEmail(email) {
    if (!email || typeof email !== 'string') return false;
    
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email.trim());
  },

  /**
   * Validate password strength (supports both manual and auto-generated)
   * @param {string} password - Password to validate
   * @param {boolean} isAutoGenerated - Whether password is auto-generated
   * @returns {object} Validation result with isValid, message, and strength
   */
  validatePassword(password, isAutoGenerated = false) {
    if (!password || typeof password !== 'string') {
      return { isValid: false, message: 'Password is required', strength: 'weak' };
    }

    if (password.length < 6) {
      return { isValid: false, message: 'Password must be at least 6 characters long', strength: 'weak' };
    }
    
    // Enhanced validation for auto-generated passwords
    if (isAutoGenerated) {
      // Check for expected pattern (capitalized words + numbers)
      const kidFriendlyPattern = /^[A-Z][a-z]+([A-Z][a-z]+)+\d{2,}$/;
      if (kidFriendlyPattern.test(password)) {
        return { isValid: true, message: 'Password is valid', strength: 'strong', format: 'kid-friendly' };
      }
    }
    
    // Calculate password strength
    let strength = 'weak';
    const hasUppercase = /[A-Z]/.test(password);
    const hasLowercase = /[a-z]/.test(password);
    const hasNumbers = /[0-9]/.test(password);
    const hasSpecial = /[^a-zA-Z0-9]/.test(password);
    
    const criteriaCount = [hasUppercase, hasLowercase, hasNumbers, hasSpecial].filter(Boolean).length;
    
    if (password.length >= 12 && criteriaCount >= 3) {
      strength = 'strong';
    } else if (password.length >= 8 && criteriaCount >= 2) {
      strength = 'moderate';
    }

    return { isValid: true, message: 'Password is valid', strength };
  },

  /**
   * Validate required fields in an object
   * @param {object} data - Data object to validate
   * @param {Array<string>} requiredFields - Array of required field names
   * @returns {object} Validation result with isValid, message, and missing fields
   */
  validateRequiredFields(data, requiredFields) {
    if (!data || typeof data !== 'object') {
      return { 
        isValid: false, 
        message: 'Data is required', 
        missingFields: requiredFields 
      };
    }

    const missingFields = requiredFields.filter(field => {
      const value = data[field];
      return !value || (typeof value === 'string' && !value.trim());
    });

    if (missingFields.length > 0) {
      return {
        isValid: false,
        message: `Missing required fields: ${missingFields.join(', ')}`,
        missingFields
      };
    }

    return { isValid: true, message: 'All required fields present' };
  },

  /**
   * Sanitize string input (trim and escape)
   * @param {string} str - String to sanitize
   * @returns {string} Sanitized string
   */
  sanitizeString(str) {
    if (!str || typeof str !== 'string') return '';
    
    return str.trim()
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;');
  },

  /**
   * Validate text length
   * @param {string} text - Text to validate
   * @param {number} minLength - Minimum length (default: 1)
   * @param {number} maxLength - Maximum length (default: 1000)
   * @returns {object} Validation result
   */
  validateTextLength(text, minLength = 1, maxLength = 1000) {
    if (!text || typeof text !== 'string') {
      return { 
        isValid: false, 
        message: `Text must be between ${minLength} and ${maxLength} characters` 
      };
    }

    const length = text.trim().length;
    
    if (length < minLength) {
      return { 
        isValid: false, 
        message: `Text must be at least ${minLength} characters long` 
      };
    }
    
    if (length > maxLength) {
      return { 
        isValid: false, 
        message: `Text must be no more than ${maxLength} characters long` 
      };
    }

    return { isValid: true, message: 'Text length is valid' };
  },

  /**
   * Validate user role
   * @param {string} role - Role to validate
   * @returns {boolean} True if valid role
   */
  isValidRole(role) {
    const validRoles = ['amitrace_admin', 'teacher', 'student'];
    return validRoles.includes(role);
  },

  /**
   * Validate database ID (must be positive integer)
   * @param {any} id - ID to validate
   * @returns {boolean} True if valid ID
   */
  isValidId(id) {
    const numId = parseInt(id, 10);
    return !isNaN(numId) && numId > 0;
  },

  /**
   * Validate and sanitize CSV data
   * @param {string} csvText - CSV text to validate
   * @returns {object} Validation result with row count and any issues
   */
  validateCSVData(csvText) {
    if (!csvText || typeof csvText !== 'string') {
      return { 
        isValid: false, 
        message: 'CSV data is required',
        rowCount: 0
      };
    }

    const lines = csvText.trim().split('\n');
    const rowCount = lines.length - 1; // Subtract header row

    if (rowCount < 1) {
      return { 
        isValid: false, 
        message: 'CSV must contain at least one data row',
        rowCount: 0
      };
    }

    if (rowCount > 1000) {
      return { 
        isValid: false, 
        message: 'CSV cannot contain more than 1000 rows',
        rowCount
      };
    }

    return { 
      isValid: true, 
      message: `CSV contains ${rowCount} valid rows`,
      rowCount
    };
  },

  /**
   * Validate file upload
   * @param {object} file - File object to validate
   * @param {Array<string>} allowedTypes - Allowed MIME types
   * @param {number} maxSize - Maximum file size in bytes
   * @returns {object} Validation result
   */
  validateFileUpload(file, allowedTypes = ['text/csv'], maxSize = 5 * 1024 * 1024) {
    if (!file) {
      return { isValid: false, message: 'File is required' };
    }

    if (!allowedTypes.includes(file.mimetype)) {
      return { 
        isValid: false, 
        message: `File type not allowed. Allowed types: ${allowedTypes.join(', ')}` 
      };
    }

    if (file.size > maxSize) {
      const maxSizeMB = Math.round(maxSize / (1024 * 1024));
      return { 
        isValid: false, 
        message: `File size too large. Maximum size: ${maxSizeMB}MB` 
      };
    }

    return { isValid: true, message: 'File is valid' };
  },

  /**
   * Create standardized error response
   * @param {string} message - Error message
   * @param {number} status - HTTP status code (default: 400)
   * @param {object} details - Additional error details
   * @returns {object} Standardized error object
   */
  createErrorResponse(message, status = 400, details = null) {
    return {
      error: message,
      status,
      timestamp: new Date().toISOString(),
      ...(details && { details })
    };
  },

  /**
   * Create standardized success response
   * @param {string} message - Success message
   * @param {any} data - Response data
   * @returns {object} Standardized success object
   */
  createSuccessResponse(message, data = null) {
    return {
      success: true,
      message,
      timestamp: new Date().toISOString(),
      ...(data && { data })
    };
  },

  /**
   * Validate auto-generated password format
   * @param {string} password - Auto-generated password to validate
   * @returns {object} Validation result with format analysis
   */
  validateGeneratedPassword(password) {
    const result = {
      valid: true,
      errors: [],
      format: 'unknown',
      components: {}
    };

    if (!password || typeof password !== 'string') {
      result.valid = false;
      result.errors.push('Password is required');
      return result;
    }

    // Check minimum length
    if (password.length < 8) {
      result.valid = false;
      result.errors.push('Password must be at least 8 characters long');
    }

    // Check for kid-friendly pattern (e.g., "BlueDolphinJump123")
    const kidFriendlyPattern = /^([A-Z][a-z]+)+([0-9]+)$/;
    const kidMatch = password.match(kidFriendlyPattern);
    
    if (kidMatch) {
      result.format = 'kid-friendly';
      // Extract word components
      const wordsSection = password.replace(/[0-9]+$/, '');
      const words = wordsSection.match(/[A-Z][a-z]+/g) || [];
      const numbers = password.match(/[0-9]+$/)?.[0] || '';
      
      result.components = {
        words,
        wordCount: words.length,
        numbers,
        numberCount: numbers.length
      };
      
      // Validate word count (should be 3 for standard format)
      if (words.length < 2) {
        result.valid = false;
        result.errors.push('Kid-friendly password should contain at least 2 words');
      }
    } else {
      // Check if it's a secure random password
      const hasUppercase = /[A-Z]/.test(password);
      const hasLowercase = /[a-z]/.test(password);
      const hasNumbers = /[0-9]/.test(password);
      const hasSpecial = /[^a-zA-Z0-9]/.test(password);
      
      if (hasUppercase && hasLowercase && hasNumbers) {
        result.format = 'secure';
        result.components = {
          hasUppercase,
          hasLowercase,
          hasNumbers,
          hasSpecial
        };
      }
    }

    return result;
  },

  /**
   * Analyze password strength and entropy
   * @param {string} password - Password to analyze
   * @returns {object} Detailed strength analysis
   */
  analyzePasswordStrength(password) {
    if (!password || typeof password !== 'string') {
      return {
        strength: 'weak',
        entropy: 0,
        score: 0,
        feedback: ['Password is required']
      };
    }

    // Character set analysis
    const hasLower = /[a-z]/.test(password);
    const hasUpper = /[A-Z]/.test(password);
    const hasDigit = /[0-9]/.test(password);
    const hasSpecial = /[^a-zA-Z0-9]/.test(password);
    
    // Calculate character set size
    let charsetSize = 0;
    if (hasLower) charsetSize += 26;
    if (hasUpper) charsetSize += 26;
    if (hasDigit) charsetSize += 10;
    if (hasSpecial) charsetSize += 32;
    
    // Calculate entropy
    const entropy = password.length * Math.log2(charsetSize);
    
    // Calculate score (0-100)
    let score = 0;
    score += Math.min(password.length * 4, 40); // Length (max 40)
    score += hasLower ? 10 : 0;
    score += hasUpper ? 10 : 0;
    score += hasDigit ? 10 : 0;
    score += hasSpecial ? 20 : 0;
    score += password.length >= 12 ? 10 : 0;
    
    // Determine strength
    let strength = 'weak';
    if (entropy >= 60 && score >= 80) {
      strength = 'very strong';
    } else if (entropy >= 50 && score >= 60) {
      strength = 'strong';
    } else if (entropy >= 40 && score >= 40) {
      strength = 'moderate';
    }
    
    // Generate feedback
    const feedback = [];
    if (password.length < 8) feedback.push('Use at least 8 characters');
    if (!hasUpper) feedback.push('Add uppercase letters');
    if (!hasLower) feedback.push('Add lowercase letters');
    if (!hasDigit) feedback.push('Add numbers');
    if (!hasSpecial) feedback.push('Consider adding special characters');
    if (password.length < 12) feedback.push('Longer passwords are more secure');
    
    return {
      strength,
      entropy: Math.round(entropy),
      score: Math.min(100, score),
      characterTypes: {
        lowercase: hasLower,
        uppercase: hasUpper,
        digits: hasDigit,
        special: hasSpecial
      },
      feedback: feedback.length ? feedback : ['Password is strong']
    };
  },

  /**
   * Validate that password uses only kid-appropriate words
   * @param {string} password - Password to check
   * @returns {boolean} True if kid-appropriate
   */
  isKidFriendlyPassword(password) {
    if (!password || typeof password !== 'string') return false;
    
    // Check for kid-friendly pattern
    const kidFriendlyPattern = /^([A-Z][a-z]+)+([0-9]+)$/;
    if (!kidFriendlyPattern.test(password)) return false;
    
    // Extract words and check they're appropriate length
    const wordsSection = password.replace(/[0-9]+$/, '');
    const words = wordsSection.match(/[A-Z][a-z]+/g) || [];
    
    // Each word should be between 3-10 characters (typical for kid-friendly words)
    return words.every(word => word.length >= 3 && word.length <= 10);
  }
};

// For Node.js module exports
if (typeof module !== 'undefined' && module.exports) {
  module.exports = validationHelpers;
}

// For browser global access
if (typeof window !== 'undefined') {
  window.ValidationHelpers = validationHelpers;
}